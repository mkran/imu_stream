
// Include libraries
#include <iostream>
#include <vector>
#include "ros/ros.h"
#include "geometry_msgs/Vector3.h"
#include "geometry_msgs/Quaternion.h"
#include "sensor_msgs/Imu.h"
#include "tf/tfMessage.h"
#include "std_msgs/Header.h"
#include "std_msgs/UInt32.h"
#include <sstream>
#include "vn/ezasyncdata.h"
#include "vn/thread.h"

using namespace std;
using namespace vn::math;
using namespace vn::protocol::uart;
using namespace vn::xplat;
using namespace vn::sensors;

// Main function
int main(int argc, char** argv) {
	// Initialize node parameters
	int publishing_buffer_size = 1000;
	int publishing_frequency = 40;
	const string SensorPort = "/dev/ttyUSB0";
	const uint32_t SensorBaudrate = 115200;

	// Initialize ROS
	ros::init(argc, argv, "imu_stream");
	// Create node handler
	ros::NodeHandle nh;
	// Create publisher with specified buffer size
	ros::Publisher imu_stream_pub = nh.advertise<sensor_msgs::Imu>("imu_stream", publishing_buffer_size);
	// Set frequency
	ros::Rate loop_rate(publishing_frequency);
	ROS_INFO("ROS initialization complete");

	// Create and connect to a sensor
	EzAsyncData* ez = EzAsyncData::connect(SensorPort, SensorBaudrate);
	ROS_INFO("Async connection complete");
	
	sensor_msgs::Imu msg;
	uint32_t count = 0;

	while (ros::ok()) {
		// Create string message object
		geometry_msgs::Vector3 msg_acc;
		geometry_msgs::Quaternion msg_quat;
		geometry_msgs::Vector3 msg_ang_vel;

		// Read in the latest data processed by the EzAsyncData class
		CompositeData cd = ez->currentData();

		// Check if there is any acceleration data available
		if (!cd.hasAcceleration()) {
			msg_acc.x = -1.0;
			msg_acc.y = -1.0;
			msg_acc.z = -1.0;
		} else {
			// If data is available, read in velocity
			vn::math::vec3 acc = cd.acceleration();
			
			msg_acc.x = acc.x;
			msg_acc.y = acc.y;
			msg_acc.z = acc.z;
		}

		// Check if there is any rotation data availablif (!cd.hasAcceleration()) {
		if (!cd.hasAnyAttitude()) {
			msg_quat.w = -1.0;
			msg_quat.x = -1.0;
			msg_quat.y = -1.0;
			msg_quat.z = -1.0;			
		} else {
			// If data is available, read in velocity
			vn::math::vec4 quat = cd.anyAttitude().quat();
			
			msg_quat.w = quat.w;
			msg_quat.x = quat.x;
			msg_quat.y = quat.y;
			msg_quat.z = quat.z;
		}

		if (!cd.hasAngularRate()) {
			msg_ang_vel.x = -1.0;
			msg_ang_vel.y = -1.0;
			msg_ang_vel.z = -1.0;			
		} else {
			// If data is available, read in velocity
			vn::math::vec3 ang = cd.angularRate();
			
			msg_ang_vel.x = ang.x;
			msg_ang_vel.y = ang.y;
			msg_ang_vel.z = ang.z;
		}

		msg.linear_acceleration = msg_acc;
		msg.orientation = msg_quat;
		msg.angular_velocity = msg_ang_vel;
		
		std_msgs::Header header;
		header.stamp = ros::Time::now();
		header.frame_id = "1";
		header.seq = count++;

		msg.header = header;

		// Publish message to topic
		imu_stream_pub.publish(msg);

		// Allow ros::Rate object to sleep to hit specified frequency
		loop_rate.sleep();
	}

	return 0;
}
