// Include libraries
#include <iostream>
#include <vector>
#include "ros/ros.h"
#include "geometry_msgs/Vector3.h"
#include <sstream>
#include "vn/ezasyncdata.h"
#include "vn/thread.h"

using namespace std;
using namespace vn::math;
using namespace vn::protocol::uart;
using namespace vn::xplat;
using namespace vn::sensors;

// Main function
int main(int argc, char** argv) {
	// Initialize node parameters
	int publishing_buffer_size = 1000;
	int publishing_frequency = 40;
	const string SensorPort = "/dev/ttyUSB0";
	const uint32_t SensorBaudrate = 115200;

	// Initialize ROS
	ros::init(argc, argv, "imu_stream");
	// Create node handler
	ros::NodeHandle nh;
	// Create publisher with specified buffer size
	ros::Publisher imu_stream_pub = nh.advertise<geometry_msgs::Vector3>("imu_stream", publishing_buffer_size);
	// Set frequency
	ros::Rate loop_rate(publishing_frequency);
	ROS_INFO("ROS initialization complete");

	// Create and connect to a sensor
	EzAsyncData* ez = EzAsyncData::connect(SensorPort, SensorBaudrate);
	ROS_INFO("Async connection complete");

	while (ros::ok()) {
		// Create string message object
		geometry_msgs::Vector3 msg;

		// Read in the latest data processed by the EzAsyncData class
		CompositeData cd = ez->currentData();

		// Check if there is any acceleration data available
		if (!cd.hasAcceleration()) {
			msg.x = -1.0;
			msg.y = -1.0;
			msg.z = -1.0;
		} else {
			// If data is available, read in velocity
			vn::math::vec3 vel = cd.anyAcceleration();
			
			msg.x = vel.x;
			msg.y = vel.y;
			msg.z = vel.z;
		}

		// Publish message to topic
		imu_stream_pub.publish(msg);

		// Allow ros::Rate object to sleep to hit specified frequency
		loop_rate.sleep();
	}

	return 0;
}
